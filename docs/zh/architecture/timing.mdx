# 时序

对于前端开发者来说，时序是一个非常重要的概念，但也是许多令人头痛的问题的根源。
为什么时序问题在前端开发中会如此突出呢？让我们一起分析一个简单的例子，来看看前端常遇到的时序问题。

## TodoList

我们来看一个简单的 TodoList 的例子。这个 TodoList 由两个页面组成，一个是添加或编辑 Todo 的详情页，另一个是展示 Todo 的列表页面。
这个场景代表了一类典型的前端交互，用户在详情页添加或编辑 Todo，然后在列表页查看所有的 Todo。
为了给读者一个直观的印象，我们在这里附上一个简单的示意图：

<center>![overview](/illustration/arch/todo-page.drawio.svg)</center>

### 创建 Todo

当用户想要创建一个新的 Todo 时，他会在详情页中输入 Todo 的内容，然后点击“保存”按钮。此时，我们期望一个顺序的时序过程：

- 用户点击“保存”按钮
- 网络请求发送，并等待响应
- 列表页刷新

看上去很简单，但是实际上，考虑到具体实现的细节，真实的时序过程可能会超乎预计地复杂：

- 用户点击“保存”按钮
- 发送保存表单的网络请求
- 详情页渲染加载中状态
- 详情页网络请求响应
- 处理路由后退，弹出当前页面

- 详情页卸载
- 列表页加载，从本地缓存中读取 Todo 列表
- 列表页渲染
- 列表页发起网络请求，获取最新的 Todo 列表
- 列表页渲染加载中状态
- 列表接口响应，更新列表页数据
- 列表页渲染

在这个过程中，涉及到了多个页面的切换、网络请求、本地缓存、页面渲染等多个环节，这些环节中有同步执行的，也有异步执行的；有些是依赖于当前状态的，有些是相对独立的。
如果考虑到用户的操作可能是不可预测的，例如在网络请求发送的过程中，用户点击了后退按钮，程序的实际执行过程可能会变得出乎意料；
如果考虑到网络请求可能失败，那么这个时序过程也会变得更加复杂。

### 陷入时序问题

那么，要如何解决这个时序问题呢？一般来说，我们可以通过以下几种方式来解决：

- 禁用用户操作，直到当前操作完成；
- 在异步任务执行完成后，检查当前状态是否允许执行下一步操作。

这两种方式都是通过控制时序来解决问题的，但是这样的方式会带来一些问题：

- 可能会牺牲一些用户体验，用户在等待时无法进行其他操作；
- 代码复杂度增加，需要在多个地方添加时序控制的逻辑；
- 时序控制的逻辑可能会分散在多个地方，导致代码难以维护；
- 程序的正确性依赖于开发者对时序的理解，非常容易出现时序错误。

有没有一种更好的方式来解决这个问题呢？fluently.js 尝试提供一种新的解决方案。

## 声明式时序

在 fluently.js 中，我们提供了一种声明式的时序控制方式。开发者可以通过声明式的方式来描述时序关系，而不需要关心具体的时序控制逻辑。

（待续）
